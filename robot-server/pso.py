# -*- coding: utf-8 -*-
"""PSO.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1wXO2das2DIE8s9JFkJ_MJiB-K3DsxWGo
"""


from optimizationalgorithm import *

# def settingup():
# # Create graph
#     graph = Graph()
#     # Add vertices
#     graph.add_node(node('S', (1,1),direction="up"))
#     graph.add_node(node('B', (1,2)))
#     graph.add_node(node('C', (1,4)))
#     graph.add_node(node('D', (2,1)))
#     graph.add_node(node('E', (2,2)))
#     graph.add_node(node('F', (2,3)))
#     graph.add_node(node('G', (2,4)))
#     graph.add_node(node('H', (3,1)))
#     graph.add_node(node('I', (3,4)))
#     graph.add_node(node('J', (4,1)))
#     graph.add_node(node('K', (4,2)))
#     graph.add_node(node('T', (4,3)))
#     graph.add_node(node('L', (4,4)))
#     graph.add_node(node('M', (3,2)))
    
#     # Add edges
#     graph.add_edge('S', 'B', 1)
#     graph.add_edge('S', 'D', 1)
#     graph.add_edge('B', 'E', 1)
#     graph.add_edge('C', 'G', 1)
#     graph.add_edge('D', 'E', 1)
#     graph.add_edge('D', 'H', 1)
#     graph.add_edge('E', 'F', 1)
#     graph.add_edge('F', 'G', 1)
#     graph.add_edge('G', 'I', 1)
#     graph.add_edge('H', 'J', 1)
#     graph.add_edge('I', 'L', 1)
#     graph.add_edge('J', 'K', 1)
#     graph.add_edge('K', 'T', 1)
#     graph.add_edge('T', 'L', 1)
#     graph.add_edge('H', 'M', 1)
#     graph.add_edge('E', 'M', 1)
#     graph.add_edge('M', 'K', 1)
#     return graph

def fitness_function(x1,x2):
    # Create graph
    graph=settingup()
    # Execute the algorithm
    startnode=graph.find_node('S')
    valuelist=['S','B','C','D','E','F','G','M','H','I','J','K','T','L']
    openlist=[]
    for x in valuelist:
      openlist.append(graph.find_node(x))
    A=createpathlist(startnode,openlist,x1,x2,graph)
    commandlist=listtorder(A,graph,valuelist)
    distance=calculatedistance(commandlist)
    return distance

def update_velocity(particle, velocity, pbest, gbest, w_min=0.5, max=1.0, c=0.1):
  # Initialise new velocity array
  num_particle = len(particle)
  new_velocity = np.array([0.0 for i in range(num_particle)])
  # Randomly generate r1, r2 and inertia weight from normal distribution
  r1 = random.uniform(0,max)
  r2 = random.uniform(0,max)
  w = random.uniform(w_min,max)
  c1 = c
  c2 = c
  # Calculate new velocity
  for i in range(num_particle):
    new_velocity[i] = w*velocity[i] + c1*r1*(pbest[i]-particle[i])+c2*r2*(gbest[i]-particle[i])
  return new_velocity

"""# 新段落"""

def update_position(particle, velocity):
  # Move particles by adding velocity
  new_particle = particle + velocity
  return new_particle

def pso_2d(population, dimension, position_min, position_max, generation, fitness_criterion):
  # Initialisation
  # Population
  particles = [[random.uniform(position_min, position_max) for j in range(dimension)] for i in range(population)]
  # Particle's best position
  pbest_position = particles
  # Fitness
  pbest_fitness = [fitness_function(p[0],p[1]) for p in particles]
  # Index of the best particle
  gbest_index = np.argmin(pbest_fitness)
  # Global best particle position
  gbest_position = pbest_position[gbest_index]
  # Velocity (starting from 0 speed)
  velocity = [[0.0 for j in range(dimension)] for i in range(population)]
  
  # Loop for the number of generation
  for t in range(generation):
    # Stop if the average fitness value reached a predefined success criterion
    if np.average(pbest_fitness) <= fitness_criterion:
      break
    else:
      for n in range(population):
        # Update the velocity of each particle
        velocity[n] = update_velocity(particles[n], velocity[n], pbest_position[n], gbest_position)
        # Move the particles to new position
        particles[n] = update_position(particles[n], velocity[n])
    # Calculate the fitness value
    pbest_fitness= [fitness_function(p[0],p[1]) for p in particles]
    # Find the index of the best particle
    gbest_index = np.argmin(pbest_fitness)
    # Update the position of the best particle
    gbest_position = pbest_position[gbest_index]


  # Print the results
  # print('Global Best Position: ', gbest_position)
  # print('Best Fitness Value: ', min(pbest_fitness))
  # print('Average Particle Best Fitness Value: ', np.average(pbest_fitness))
  # print('Number of Generation: ', t)
  return gbest_position



#获得指示
def commandlistoutput():
  population = 100
  dimension = 2
  position_min = -100.0
  position_max = 100.0
  generation = 20
  fitness_criterion = 10e-4
  gbest_position=pso_2d(population,dimension,position_min,position_max,generation,fitness_criterion)
  graph=settingup()
  # Execute the algorithm
  startnode=graph.find_node('S')
  valuelist=['S','B','C','D','E','F','G','M','H','I','J','K','T','L']
  openlist=[]
  for x in valuelist:
    openlist.append(graph.find_node(x))
  A=createpathlist(startnode,openlist,gbest_position[0],gbest_position[1],graph)
  #这个是最后的指示集
  commandlist=listtorder(A,graph,valuelist)
  return commandlist,A